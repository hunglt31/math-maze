<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Maze üîó</title>
    <style>
        /* General Setup */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f8ff; 
        }
        h1 {
            color: #00bcd4; 
        }
        #game-container {
            width: 1200px;
            height: 900px; 
            position: relative; 
            margin-top: 30px;
        }
        
        /* Question and Final Boxes (outside the path) */
        .box {
            width: 200px; 
            height: 60px; 
            line-height: 60px;
            text-align: center;
            background-color: #ffffff;
            border: 3px solid #b3e5fc; 
            border-radius: 12px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            position: absolute; 
            z-index: 10; 
            box-sizing: border-box;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), inset 0 0 10px rgba(255, 255, 255, 0.5); 
            display: flex; /* For centering content within the box */
            align-items: center;
            justify-content: center;
            padding-left: 10px; /* Space for the result icon */
        }
        .question:hover { border-color: #00bcd4; background-color: #e0f7fa; }
        .question.selected { color: black; border-color: #006064; } 
        
        /* Specific colors for Question Boxes */
        #q-10x5.selected { background-color: #D32F2F; } 
        #q-7\+5.selected { background-color: #1976D2; } 
        #q-6\+8.selected { background-color: #F57C00; } 
        #q-15x4.selected { background-color: #388E3C; } 

        .final-answer-box {
            background-color: #1e88e5; 
            color: white;
            cursor: default;
            border-color: #0d47a1;
            font-size: 1.5em; 
            padding-left: 0; /* Reset padding */
        }

        /* Answer content and icon alignment */
        .answer-content {
            flex-grow: 1; /* Allows the text to take up space */
            text-align: center;
        }
        
        /* New styles for result icons */
        .result-icon {
            width: 30px;
            height: 30px;
            line-height: 30px;
            font-size: 1.5em;
            font-weight: bold;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }
        .correct { color: #4CAF50; } /* Green tick */
        .wrong { color: #F44336; } /* Red X */
        
        /* Message Display */
        #message {
            margin-top: 20px;
            font-size: 1.4em;
            color: #ef5350; 
            min-height: 30px;
            font-weight: bold;
        }
        
        /* Canvas */
        #mazeCanvas {
            background-color: #e3f2fd; 
            position: absolute; 
            left: 200px; 
            top: 0;
            z-index: 1;
            border-radius: 15px; 
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.3), inset 0 0 15px rgba(0, 0, 0, 0.1); 
        }

        /* --- CONTROL BUTTONS --- */
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        .control-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }

        #submit-btn {
            background-color: #4CAF50;
            color: white;
        }

        #submit-btn:hover { background-color: #388E3C; transform: translateY(-2px); }
        #submit-btn:disabled { background-color: #cccccc; cursor: not-allowed; }

        #show-answer-btn {
            background-color: #FFC107;
            color: #333;
            display: none; /* Initially hidden */
        }
        #show-answer-btn:hover { background-color: #FFB300; transform: translateY(-2px); }

        /* --- NEW MODAL STYLES --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 999;
            inset: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(0,0,0,0.5), rgba(0,0,0,0.8));
            backdrop-filter: blur(6px);
            animation: fadeIn 0.3s ease-in-out;
        }

        .modal-content {
            background: linear-gradient(180deg, #ffffff, #f5f5f5);
            margin: 6% auto;
            padding: 50px 40px;
            border-radius: 40px;
            text-align: center;
            width: 600px;
            max-width: 90vw;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            position: relative;
            animation: popUp 0.35s ease-in-out;
            transform-origin: center;
        }

        /* üîµ Big circular hero image */
        .modal-content img {
            width: 260px;
            height: 260px;
            border-radius: 50%;
            object-fit: cover;
            border: 10px solid #fff;
            box-shadow: 0 0 25px rgba(0,0,0,0.25);
            margin-bottom: 30px;
            transition: transform 0.3s ease;
        }

        .modal-content img:hover {
            transform: scale(1.05) rotate(2deg);
        }

        /* ‚ú® Title */
        .modal-content h2 {
            font-size: 3rem;
            color: #2E7D32;
            margin-bottom: 20px;
            letter-spacing: 1px;
            font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.15);
        }

        /* üìù Text */
        .modal-content p {
            font-size: 2rem;
            color: #333;
            line-height: 1.6;
            font-weight: 600;
            margin: 0 auto;
            max-width: 500px;
        }

        /* ‚ùå Close button */
        .close {
            position: absolute;
            right: 25px;
            top: 15px;
            color: #666;
            font-size: 36px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close:hover {
            color: #000;
        }

        /* üåÄ Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes popUp {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
    </style>
</head>

<body>
    <h1>Nexus Maze üîó</h1>

    <div id="message"></div>
    
    <div id="game-container">
        <canvas id="mazeCanvas"></canvas>

        <div class="box question" id="q-10x5" data-q-key="10 g·∫•p 5 l·∫ßn" data-correct-val="50">10 g·∫•p 5 l·∫ßn</div>
        <div class="box question" id="q-7+5" data-q-key="7 th√™m 5 ƒë∆°n v·ªã" data-correct-val="12">7 th√™m 5 ƒë∆°n v·ªã</div>
        <div class="box question" id="q-6+8" data-q-key="6 th√™m 8 ƒë∆°n v·ªã" data-correct-val="14">6 th√™m 8 ƒë∆°n v·ªã</div>
        <div class="box question" id="q-15x4" data-q-key="15 g·∫•p 4 l·∫ßn" data-correct-val="60">15 g·∫•p 4 l·∫ßn</div>
        
        <div class="box final-answer-box" id="fb-0">
            <span class="answer-content">?</span>
        </div>
        <div class="box final-answer-box" id="fb-1">
            <span class="answer-content">?</span>
        </div>
        <div class="box final-answer-box" id="fb-2">
            <span class="answer-content">?</span>
        </div>
        <div class="box final-answer-box" id="fb-3">
            <span class="answer-content">?</span>
        </div>

    </div>
    
    <div id="controls">
        <button id="submit-btn" class="control-btn" disabled>N·ªôp ƒë√°p √°n</button>
        <button id="show-answer-btn" class="control-btn">Xem ƒë√°p √°n</button>
    </div>

    <!-- ‚úÖ SUCCESS MODAL -->
    <div id="successModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('successModal')">&times;</span>
            <h2 id="successTitle">üéâ Ch√≠nh x√°c!</h2>
            <img id="successImage" src="" alt="Success Image">
            <p id="successText"></p>
        </div>
    </div>

    <!-- ‚ùå NICE TRY MODAL -->
    <div id="niceTryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('niceTryModal')">&times;</span>
            <h2>ü§ó Ch∆∞a ƒë√∫ng!</h2>
            <img src="images/co-ngan.png" alt="Nice Try Image">
            <p id="niceTryText">ƒê√°p √°n ch∆∞a ch√≠nh x√°c! Con h√£y th·ª≠ l·∫°i nh√©!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const questionBoxes = document.querySelectorAll('.question');
        const finalAnswerBoxes = document.querySelectorAll('.final-answer-box');
        const submitBtn = document.getElementById('submit-btn');
        const showAnswerBtn = document.getElementById('show-answer-btn');

        // --- SOUND EFFECTS SETUP ---
        const soundStart = new Audio('sounds/tingting.mp3');
        const soundSuccess = new Audio('sounds/success-340660.mp3');
        const soundFail = new Audio('sounds/fail-234710.mp3');
        const soundCheckpointBlip = new Audio('sounds/blip-131856.mp3');
        const soundSelect = new Audio('sounds/sharp-pop-328170.mp3');

        // Pre-load the audio (optional but helpful)
        soundStart.load();
        soundSuccess.load();
        soundFail.load();
        soundCheckpointBlip.load();
        soundSelect.load();

        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 900;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // CSS offsets
        const CANVAS_OFFSET_X = 200; 
        const CANVAS_OFFSET_Y = 0;   
        
        // Path/Drawing Constants
        const PATH_LINE_WIDTH = 50; 
        const segmentDrawDuration = 2000; 
        const CHECKPOINT_RADIUS = 20;
        const HITBOX_TOLERANCE = 0.3; 

        // Color mapping
        const COLOR_MAP = {
            "q-10x5": { base: "rgba(229, 115, 115, 0.6)", highlight: "#FF0000" }, // Red
            "q-7+5": { base: "rgba(100, 181, 246, 0.6)", highlight: "#0000FF" }, // Blue
            "q-6+8": { base: "rgba(255, 213, 79, 0.6)", highlight: "#FFA500" }, // Orange
            "q-15x4": { base: "rgba(129, 199, 132, 0.6)", highlight: "#00FF00" } // Green
        };

        let selectedQuestion = null;
        let isPathAnimating = false;
        let animationFrameId = null;
        let currentPathIndex = 0; 
        let startTime = null; 
        let checkpointsPassed = new Set(); 
        let currentSegmentProgress = 0;
        
        const BOX_ELEMENTS = {};
        document.querySelectorAll('.box').forEach(box => { BOX_ELEMENTS[box.id] = box; });

        // --- NEW STATE MANAGEMENT ---
        // Store the user's chosen answer for each question ID
        const userAnswers = {
            'q-10x5': null, 
            'q-7+5': null,
            'q-6+8': null,
            'q-15x4': null,
        };
        const FINAL_BOX_MAP = {
            'q-10x5': 'fb-0', 
            'q-7+5': 'fb-1',
            'q-6+8': 'fb-2',
            'q-15x4': 'fb-3',

        };

        // --- Path Definitions (Same Grid-Locked paths) ---
        const PATHS = {
            "q-10x5": { 
                color: COLOR_MAP["q-10x5"],
                points: [
                    { x: 0, y: 50 }, 
                    { x: 300, y: 50 }, 
                    { x: 300, y: 700 }, 
                    { x: 800, y: 700 }, 
                    { x: 800, y: 50 }, 
                    { x: 950, y: 50 }
                ], 
                finalBoxID: 'fb-0' 
            }, 
            "q-7+5": { 
                color: COLOR_MAP["q-7+5"],
                points: [
                    { x: 0, y: 250 }, 
                    { x: 100, y: 250 }, 
                    { x: 100, y: 800 }, 
                    { x: 600, y: 800 }, 
                    { x: 600, y: 250 }, 
                    { x: 950, y: 250 } 
                ], 
                finalBoxID: 'fb-1' 
            },
            "q-6+8": { 
                color: COLOR_MAP["q-6+8"],
                points: [
                    { x: 0, y: 450 }, 
                    { x: 200, y: 450 }, 
                    { x: 200, y: 150 }, 
                    { x: 750, y: 150 }, 
                    { x: 750, y: 450 }, 
                    { x: 950, y: 450 } 
                ], 
                finalBoxID: 'fb-2' 
            },
            "q-15x4": { 
                color: COLOR_MAP["q-15x4"],
                points: [
                    { x: 0, y: 650 }, 
                    { x: 450, y: 650 }, 
                    { x: 450, y: 100 }, 
                    { x: 900, y: 100 }, 
                    { x: 900, y: 850 }, 
                    { x: 950, y: 850 } 
                ], 
                finalBoxID: 'fb-3' 
            }
        };

        // --- Checkpoint Cleanup for Shared Locations ---
        const INTERSECTION_POINTS = {
            '100,450': { x: 100, y: 450, val: "68", paths: ["q-7+5", "q-6+8"] },
            '300,650': { x: 300, y: 650, val: "45", paths: ["q-10x5", "q-15x4"] },
            '450,150': { x: 450, y: 150, val: "48", paths: ["q-6+8", "q-15x4"] },
            '750,250': { x: 750, y: 250, val: "14", paths: ["q-7+5", "q-6+8"] },
            '800,100': { x: 800, y: 100, val: "100", paths: ["q-10x5", "q-15x4"] },
            '900,450': { x: 900, y: 450, val: "60", paths: ["q-6+8", "q-15x4"] }
        };

        const CHECKPOINTS = [
            { id: 1, qID: "q-10x5", val: "15", segIndex: 0, t: 0.65 },
            { id: 2, qID: "q-10x5", val: "50", segIndex: 1, t: 0.35 },

            { id: 8, qID: "q-7+5", val: "35", segIndex: 2, t: 0.5 },
            { id: 9, qID: "q-7+5", val: "12", segIndex: 3, t: 0.5 },


            // (100,450) q-7+5 √ó q-6+8
            { id: 1, qID: "q-7+5", val: "68", segIndex: 1, t: 0.364, isShared: true },
            { id: 2, qID: "q-6+8",  val: "68", segIndex: 0, t: 0.500, isShared: true },

            // (300,650) q-10x5 √ó q-15x4
            { id: 7, qID: "q-10x5", val: "45", segIndex: 1, t: 0.857, isShared: true },
            { id: 8, qID: "q-15x4",  val: "45", segIndex: 0, t: 0.667, isShared: true },

            // (450,150) q-6+8 √ó q-15x4
            { id: 9, qID: "q-6+8",  val: "48", segIndex: 2, t: 0.333, isShared: true },
            { id: 10, qID: "q-15x4", val: "48", segIndex: 1, t: 0.85, isShared: true },

            // (750,250) q-7+5 √ó q-6+8
            { id: 13, qID: "q-7+5", val: "14", segIndex: 4, t: 0.333, isShared: true },
            { id: 14, qID: "q-6+8",  val: "14", segIndex: 3, t: 0.250, isShared: true },

            // (800,100) q-10x5 √ó q-15x4
            { id: 15, qID: "q-10x5", val: "100", segIndex: 3, t: 0.85, isShared: true },
            { id: 16, qID: "q-15x4",  val: "100", segIndex: 2, t: 0.775, isShared: true },

            // (900,450) q-6+8 √ó q-15x4
            { id: 23, qID: "q-6+8",  val: "60", segIndex: 4, t: 0.750, isShared: true },
            { id: 24, qID: "q-15x4",  val: "60", segIndex: 3, t: 0.467, isShared: true }
        ];

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
        }

        function showSuccessModal(qID, questionText, correctVal) {
            const successImages = {
                "q-10x5": "images/grandma.jpg",
                "q-7+5": "images/mom.jpg",
                "q-6+8": "images/teacher.jpg",
                "q-15x4": "images/classmate.jpg",
            };

            // Define different titles and messages per question
            const successMessages = {
                "q-10x5": {
                    title: "üéâ Ch√°u c·ªßa b√† gi·ªèi qu√°!",
                    text: `K·∫øt qu·∫£: ${questionText} ƒë∆∞·ª£c ${correctVal}`
                },
                "q-7+5": {
                    title: "üåü Con th·∫≠t th√¥ng minh!",
                    text: `K·∫øt qu·∫£: ${questionText} ƒë∆∞·ª£c ${correctVal}`
                },
                "q-6+8": {
                    title: "üöÄ Hay l·∫Øm! Ti·∫øp t·ª•c nh√©!",
                    text: `K·∫øt qu·∫£: ${questionText} ƒë∆∞·ª£c ${correctVal}`
                },
                "q-15x4": {
                    title: "üèÜ C·∫≠u l√†m r·∫•t t·ªët!",
                    text: `K·∫øt qu·∫£: ${questionText} ƒë∆∞·ª£c ${correctVal}`
                }
            };


            const modal = document.getElementById("successModal");
            const img = document.getElementById("successImage");
            const title = document.getElementById("successTitle");
            const text = document.getElementById("successText");

            // Pick correct image and message
            const imageSrc = successImages[qID] || "images/co-ngan.png";
            const message = successMessages[qID] || {
                title: "üéâ Ch√≠nh x√°c!",
                text: `${questionText} l√† ${correctVal}!`
            };

            // Apply modal content
            img.src = imageSrc;
            title.textContent = message.title;
            text.textContent = message.text;

            // Show modal
            modal.style.display = "block";

            // Auto-close modal after 5s (shorter than 30s)
            setTimeout(() => closeModal("successModal"), 5000);
        }

        function showNiceTryModal(message) {
            const modal = document.getElementById("niceTryModal");
            const text = document.getElementById("niceTryText");
            text.textContent = message;
            modal.style.display = "block";

            setTimeout(() => closeModal("niceTryModal"), 10000);
        }

        function getCheckpointCanvasPosition(cp) {
            const pathDef = PATHS[cp.qID];
            const startPoint = pathDef.points[cp.segIndex];
            const endPoint = pathDef.points[cp.segIndex + 1];

            const x = startPoint.x + (endPoint.x - startPoint.x) * cp.t;
            const y = startPoint.y + (endPoint.y - startPoint.y) * cp.t;
            return { x, y };
        }

        // --- Positioning Logic ---
        function placeElements() {
            for (const qID in PATHS) {
                const pathDef = PATHS[qID];
                const startPoint = pathDef.points[0];
                const endPoint = pathDef.points[pathDef.points.length - 1];
                
                const qBox = BOX_ELEMENTS[qID];
                qBox.style.left = `${CANVAS_OFFSET_X + startPoint.x - 180}px`; 
                qBox.style.top = `${CANVAS_OFFSET_Y + startPoint.y - 30}px`; 

                const fbBox = BOX_ELEMENTS[pathDef.finalBoxID];
                fbBox.style.left = `${CANVAS_OFFSET_X + endPoint.x + 30}px`; 
                fbBox.style.top = `${CANVAS_OFFSET_Y + endPoint.y - 30}px`; 
            }
        }

        // --- Drawing Functions (No changes needed for base drawing) ---
        function clearCanvas() { ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); }

        function drawPathSegments(pathDefinition, color, lineWidth, startSegment, endSegment, progress = 1) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = (color === pathDefinition.color.base) ? 'round' : 'butt'; 
            ctx.lineJoin = 'miter'; 
            
            if (color === pathDefinition.color.base) {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 10;
            } else {
                ctx.shadowColor = pathDefinition.color.highlight;
                ctx.shadowBlur = 15;
            }

            ctx.beginPath();
            
            ctx.moveTo(pathDefinition.points[startSegment].x, pathDefinition.points[startSegment].y);
            
            for (let i = startSegment + 1; i < pathDefinition.points.length; i++) {
                if (i <= endSegment) {
                    ctx.lineTo(pathDefinition.points[i].x, pathDefinition.points[i].y);
                } else if (i === endSegment + 1 && progress > 0) {
                    const startPoint = pathDefinition.points[endSegment];
                    const endPoint = pathDefinition.points[endSegment + 1];

                    const currentX = startPoint.x + (endPoint.x - startPoint.x) * progress;
                    const currentY = startPoint.y + (endPoint.y - startPoint.y) * progress;
                    
                    ctx.lineTo(currentX, currentY);
                    break;
                }
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0; 
        }
        
        function drawCheckpoint(x, y, val) {
            ctx.font = "bold 24px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            let checkpointFill = "rgba(255, 255, 255, 0.9)"; 
            let checkpointText = "#000000";

            // 1. Draw the circle 
            ctx.beginPath();
            ctx.arc(x, y, CHECKPOINT_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = checkpointFill;
            ctx.fill();
            
            // 2. Draw the number with a white stroke (Underpass Effect)
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 5;

            ctx.strokeText(val, x, y); 
            
            ctx.shadowBlur = 0; 
            ctx.fillStyle = checkpointText;
            ctx.fillText(val, x, y); 
        }

        function drawAllCheckpoints() {
            const drawnLocations = {}; 

            // First, process and draw shared intersection checkpoints
            for (const key in INTERSECTION_POINTS) {
                const ip = INTERSECTION_POINTS[key];
                drawCheckpoint(ip.x, ip.y, ip.val);
                drawnLocations[`${ip.x},${ip.y}`] = true;
            }
            
            // Second, process and draw unique non-intersection checkpoints
            CHECKPOINTS.filter(cp => !cp.isShared).forEach(cp => {
                const pos = getCheckpointCanvasPosition(cp);
                
                if (!drawnLocations[`${Math.round(pos.x)},${Math.round(pos.y)}`]) {
                    drawCheckpoint(pos.x, pos.y, cp.val);
                }
            });
        }
        
        // --- Core Drawing Loop ---
        function drawAllPaths() {
            clearCanvas();
            // 1. Draw all paths using their distinct base colors
            for (const qKey in PATHS) {
                const pathDef = PATHS[qKey];
                drawPathSegments(pathDef, pathDef.color.base, PATH_LINE_WIDTH, 0, pathDef.points.length - 1, 1);
            }
            // 2. Draw all checkpoints (Answers)
            drawAllCheckpoints();
        }

        // --- Animation / Game Logic ---
        function resetGame(fullReset = true) {
            cancelAnimationFrame(animationFrameId);
            isPathAnimating = false;
            currentPathIndex = 0;
            startTime = null;
            checkpointsPassed.clear(); 
            successModal.style.display = 'none'; 
            
            if (fullReset) {
                questionBoxes.forEach(q => q.classList.remove('selected'));
                selectedQuestion = null;
            }
            drawAllPaths(); 
        }

        function animatePathStep(timestamp) {
            if (!startTime) startTime = timestamp; 
            const elapsed = timestamp - startTime;

            if (!isPathAnimating || !selectedQuestion) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const pathDef = PATHS[selectedQuestion.id];
            
            // --- Calculate Progress ---
            const segmentCount = pathDef.points.length - 1;
            const totalPathDuration = segmentDrawDuration * segmentCount;
            
            const progressRatio = elapsed / totalPathDuration; 
            
            let completedSegments = Math.floor(elapsed / segmentDrawDuration);
            // let currentSegmentProgress = (elapsed % segmentDrawDuration) / segmentDrawDuration;
            currentSegmentProgress = (elapsed % segmentDrawDuration) / segmentDrawDuration;

            completedSegments = Math.min(completedSegments, segmentCount); 
            
            currentPathIndex = completedSegments; 

            // --- Redraw Scene ---
            drawAllPaths(); 

            // 2. Draw the illuminated path (the actual moving light)
            let drawEndIndex = completedSegments;
            let progressToDraw = (drawEndIndex === segmentCount) ? 1 : currentSegmentProgress;

            drawPathSegments(pathDef, pathDef.color.highlight, PATH_LINE_WIDTH - 15, 0, drawEndIndex, progressToDraw);

            // 3. Redraw the checkpoints again 
            drawAllCheckpoints();
            
            // --- Checkpoint Sound Logic ---
            const activePathCheckpoints = CHECKPOINTS.filter(c => c.qID === selectedQuestion.id);
            activePathCheckpoints.forEach(cp => {
                // If on the completed segment OR on the current segment and passed 't'
                const hasPassed = (cp.segIndex < completedSegments) || 
                                  (cp.segIndex === completedSegments && currentSegmentProgress >= cp.t);
                
                if (hasPassed && !checkpointsPassed.has(cp.id)) {
                    soundCheckpointBlip.currentTime = 0;
                    soundCheckpointBlip.play().catch(e => {}); 
                    checkpointsPassed.add(cp.id);
                }
            });

            // Check for path end 
            if (progressRatio >= 1.05) { 
                setTimeout(() => resetGame(true), 0);
                return;
            }

            animationFrameId = requestAnimationFrame(animatePathStep);
        }

        // --- New Logic: Find and Display Chosen Answer ---
        function handleKeypress(event) {
            if (event.key !== ' ' || !isPathAnimating || !selectedQuestion) return;

            event.preventDefault(); 
            cancelAnimationFrame(animationFrameId);
            isPathAnimating = false;

            const activeSegmentIndex = currentPathIndex; 
            const relevantCheckpoints = CHECKPOINTS.filter(c => c.qID === selectedQuestion.id);

            let chosenCheckpointValue = null;
            let finalSegmentProgress = currentSegmentProgress;

            relevantCheckpoints.forEach(cp => {
                if (cp.segIndex === activeSegmentIndex) {
                if (finalSegmentProgress >= cp.t - HITBOX_TOLERANCE && finalSegmentProgress <= cp.t + HITBOX_TOLERANCE) {
                    const cpPos = getCheckpointCanvasPosition(cp);
                    let checkpointValue = cp.val;
                    for (const key in INTERSECTION_POINTS) {
                    if (INTERSECTION_POINTS[key].x === Math.round(cpPos.x) && INTERSECTION_POINTS[key].y === Math.round(cpPos.y)) {
                        checkpointValue = INTERSECTION_POINTS[key].val;
                        break;
                    }
                    }
                    chosenCheckpointValue = checkpointValue;
                }
                }
            });

            if (chosenCheckpointValue) {
                const qID = selectedQuestion.id;
                const finalBox = BOX_ELEMENTS[FINAL_BOX_MAP[qID]];
                const correctVal = selectedQuestion.dataset.correctVal;
                const questionText = selectedQuestion.dataset.qKey;

                userAnswers[qID] = chosenCheckpointValue;
                finalBox.querySelector('.answer-content').textContent = chosenCheckpointValue;
                finalBox.querySelectorAll('.result-icon').forEach(icon => icon.remove());

                const chosenIcon = document.createElement('span');
                chosenIcon.classList.add('result-icon');

                if (chosenCheckpointValue === correctVal) {
                    chosenIcon.classList.add('correct');
                    chosenIcon.textContent = '‚úÖ';
                    try { soundSuccess.currentTime = 0; soundSuccess.play(); } catch(e) {}

                    // ‚úÖ Show success modal based on question number
                    showSuccessModal(qID, questionText, correctVal);
                } else {
                    chosenIcon.classList.add('wrong');
                    chosenIcon.textContent = '‚ùå';
                    try { soundFail.currentTime = 0; soundFail.play(); } catch(e) {}

                    // ‚ùå Show Nice Try modal
                    showNiceTryModal("Con h√£y th·ª≠ l·∫°i nh√©. C√¥ Ng√¢n tin l·∫ßn n√†y con s·∫Ω l√†m ƒë∆∞·ª£c! üíñ");
                }

                finalBox.appendChild(chosenIcon);
                updateSubmitButtonState();

                try { soundSelect.currentTime = 0; soundSelect.play(); } catch(e) {}
            } else {
                // Missed checkpoint
                showNiceTryModal("‚ö†Ô∏è Con ƒë√£ b·ªè l·ª° m·ª•c ti√™u! H√£y ch·ªçn l·∫°i c√¢u h·ªèi v√† th·ª≠ l·∫°i nh√©!");
                try { soundFail.currentTime = 0; soundFail.play(); } catch(e) {}
            }

            if (selectedQuestion) selectedQuestion.classList.remove('selected');
            selectedQuestion = null;
            currentPathIndex = 0;
            startTime = null;
            checkpointsPassed.clear();

            drawAllPaths();
        }

        function handleQuestionClick(event) {
            const questionID = event.currentTarget.id;
            
            if (isPathAnimating) return; 

            resetGame(false); 
            
            selectedQuestion = event.currentTarget;
            selectedQuestion.classList.add('selected');

            isPathAnimating = true;
            currentPathIndex = 0;
            startTime = null; 
            
            // Play start sound
            soundStart.currentTime = 0;
            soundStart.play().catch(e => console.log("Audio Autoplay Blocked:", e));
            
            animationFrameId = requestAnimationFrame(animatePathStep);
        }

        function updateSubmitButtonState() {
            const allAnswered = Object.values(userAnswers).every(answer => answer !== null);
            submitBtn.disabled = !allAnswered;
        }

        // --- Grading and Submission Logic ---
        function handleSubmit() {
            if (submitBtn.disabled) return;
            
            let allCorrect = true;
            
            // 1. Grade all answers
            questionBoxes.forEach(qBox => {
                const qID = qBox.id;
                const finalBox = BOX_ELEMENTS[FINAL_BOX_MAP[qID]];
                const correctVal = qBox.dataset.correctVal;
                const chosenVal = userAnswers[qID];
                
                // Clear previous icons
                finalBox.querySelectorAll('.result-icon').forEach(icon => icon.remove());
                
                let icon = document.createElement('span');
                icon.classList.add('result-icon');
                
                if (chosenVal === correctVal) {
                    icon.classList.add('correct');
                    icon.textContent = '‚úÖ';
                } else {
                    icon.classList.add('wrong');
                    icon.textContent = '‚ùå';
                    allCorrect = false;
                }
                
                finalBox.appendChild(icon);
            });
            
            // 2. Show congratulation message on finish (regardless of correctness)
            soundSuccess.currentTime = 0;
            soundSuccess.play().catch(e => {}); 

            modalAnswerText.textContent = allCorrect 
                ? "Ch√∫c m·ª´ng con! Con ƒë√£ ho√†n th√†nh xu·∫•t s·∫Øc t·∫•t c·∫£ c√°c c√¢u h·ªèi."
                : "Con ƒë√£ ho√†n th√†nh! H√£y xem l·∫°i nh·ªØng c√¢u c√≤n ‚ùå v√† th·ª≠ l√†m l·∫°i nh√©.";

            successModal.style.display = 'block';

            // 3. Update buttons
            submitBtn.style.display = 'none';
            showAnswerBtn.style.display = 'block';
            
            // Disable question selection after submission
            questionBoxes.forEach(q => q.removeEventListener('click', handleQuestionClick));
            document.removeEventListener('keydown', handleKeypress);
            document.querySelectorAll('[id$="-marker"]').forEach(marker => marker.remove());
        }

        function handleShowAnswer() {
            questionBoxes.forEach(qBox => {
                const qID = qBox.id;
                const finalBox = BOX_ELEMENTS[FINAL_BOX_MAP[qID]];
                const correctVal = qBox.dataset.correctVal;

                // Clear user answer and show correct answer
                finalBox.querySelector('.answer-content').textContent = correctVal;
                
                // Set the correct icon
                finalBox.querySelectorAll('.result-icon').forEach(icon => icon.remove());
                let icon = document.createElement('span');
                icon.classList.add('result-icon', 'correct');
                icon.textContent = '‚úÖ';
                finalBox.appendChild(icon);
            });

            showAnswerBtn.disabled = true;
        }

        // --- Initialization ---
        
        placeElements(); 

        questionBoxes.forEach(box => {
            box.addEventListener('click', handleQuestionClick);
        });
        
        document.addEventListener('keydown', handleKeypress);
        submitBtn.addEventListener('click', handleSubmit);
        showAnswerBtn.addEventListener('click', handleShowAnswer);
        successModal.addEventListener('click', () => successModal.style.display = 'none'); // Close modal on click

        drawAllPaths();
        updateSubmitButtonState(); // Initial check for submit button state
    </script>
</body>
</html>